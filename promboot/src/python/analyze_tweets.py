#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, json, sys
import tweepy

'''
Use help(tweepy.API) for help, as the doc is not updated sometimes
'''
_script_dir = os.path.realpath(os.path.dirname(__file__))

# Config
_error = {"LOAD_CONF" : 1, "OAUTH_ERROR" : 2}
_conf_dir = os.path.join(_script_dir, '..', '..', 'conf')
_conf = dict()

# Load config file
try: 
    path = os.path.join(_conf_dir, 'conf.json')
    with open(path, 'r') as conf_f:
        _conf = json.load(conf_f)
    path = os.path.join(_conf_dir, 'twitter_secrets.json')
    with open(path, 'r') as conf_f:
        _conf["twitter"].update(json.load(conf_f))
except Exception as e:
    sys.stderr.write("Error loading configuration from path " + path + os.linesep)
    sys.stderr.write(str(e) + os.linesep)
    sys.exit(_error["LOAD_CONF"])

def authenticate(rebuild=False):
    '''
    Return an OAuthHandler after the autentication process.
    If rebuild is true then any access token and key stored in disk will be ignored

    Following https://pythonhosted.org/tweepy/html/auth_tutorial.html?highlight=oauthhandler
    '''
    # create OAuthHandler with the consumer token and secret for 
    # the corresponding Twitter app
    auth = tweepy.OAuthHandler(_conf["twitter"]["key"], _conf["twitter"]["secret"])

    # "Twitter currently does not expire the tokens, so the only time it would ever
    # go invalid is if the user revokes our application access." So lets try to 
    # reuse the access token an secret, stored in disk
    credentials_path = os.path.join(_script_dir, _conf["twitter"]["credentials_filename"])
    if (not rebuild) and os.path.exists(credentials_path):
        try: 
            # reuse existing access token and secret
            with open(credentials_path, 'r') as creds_f:
                credentials = json.load(creds_f)
                access_key, access_secret = credentials["access_key"], credentials["access_secret"]
            # rebuild the OAuthHandler with the access and secret key
            auth.set_access_token(access_key, access_secret)
            return auth
        except:
            # try autentication from scratch
            pass
    
    # Otherwise do the OAuth dance: to exchange request token for an access token
    # ask for user autorization using the URL generated by auth from the request 
    # token
        # Ask the use to go to Tweeter to authorize and geting a verifier code
    print "Please go to {url} to authorize the app {app} and input the verifier code here".format(url=auth.get_authorization_url(), app=_conf["twitter"]["appname"])
    verifier_code = raw_input("Verifier code: " )
    try:
        # exchange the request stored in auth token for an access token by providing
        # the verifier code as a proof of user autorization
        auth.get_access_token(verifier_code)
    except tweepy.TweepError as tpe:
        sys.stderr.write("Error getting access to Twitter app {app}".format(app=_conf["twitter"]["appname"]) + os.linesep)
        sys.stderr.write(str(tpe) + os.linesep) 
        sys.exit(_error["OAUTH_ERROR"])
    print "Authentication in Twitter for app {app} succeed".format(app=_conf["twitter"]["appname"])
        # Store access token and secret key in disk for future use
    try: 
        with open(credentials_path, 'w') as creds_f:
            json.dump({"access_key" : auth.access_token.key, "access_secret" : auth.access_token.secret}, creds_f)
    except Exception as e:
        sys.stderr.write("Error saving access token and secret" + os.linesep) 
        sys.stderr.write(str(e) + os.linesep)
        sys.exit(_error["OAUTH_ERROR"])
    return auth

def explore_trends(api, woeid = 23424950):
    # for tweet in api.trends_available():
    # Me da {'name': 'Spain', 'countryCode': 'ES', 'url': 'http://where.yahooapis.com/v1/place/23424950', 'country': 'Spain', 'parentid': 1, 'placeType': {'code': 12, 'name': 'Country'}, 'woeid': 23424950}
    # for tweet in api.trends_place(23424950):
        # print tweet
    response = api.trends_place(woeid)
    # pruebo solo con la primera trend
    trends = response[0]["trends"]
    print trends[0]
    results = api.search(q=trends[0]["query"])
    # print dir(results[0])
    # print "\n", '|'.join(map(str,[results[0].geo, results[0].lang, results[0].metadata, results[0].place, results[0].created_at, results[0].entities, results[0].text]))
    for k, v in results[0].__dict__.iteritems():
        print "\t", k, ':', v

def get_trending_topics_text(api, place="ES-Madrid"): #woeid = 23424950):
    '''
    api - tweepy.api.API object
    place - string encoding a location as in configuration file

    Trends have the shape:
        {'url': 'http://twitter.com/search?q=%23euroUPyD', 'query': '%23euroUPyD', 'name': '#euroUPyD', 'promoted_content': None, 'events': None}

    Returns a list of dictionaries with keys 'name' and 'query' corresponding to hashtags for the 10 most trending topics for that location, e.g. [{'query': '%22Adolfo+Su%C3%A1rez%22', 'name': u'Adolfo Su\xe1rez'}, ...]
    '''
    response = api.trends_place(api.trends_closest(**_conf["places"][place])[0]["woeid"])
    return [{k : trend[k] for k in ['name', 'query']} for trend in response[0]['trends'] ]

def get_tweets_for_trends(api, trends, popular = False, count=15, tweet_processor = None, **search_params):
    '''
    Launch a search to Twitter for tweets corresponding to the trend spec in the list trends, that has the format returned by get_trending_topics_text(). 

    api - tweepy.api.API object
    trends - list of dictionaries in the format returned by get_trending_topics_text()
    count - number of tweets to retrieve per element in trends
    popular - whether to search for poular tweets (result_type 'popular' in the queries) or not. This limits the result to 15 tweets maximum ignoring 'count', for what it appears to be a bug https://dev.twitter.com/discussions/19472.
    tweet_processor -  Function that takes an object of the class tweepy.models.Status and returns a dictionary corresponding to projecting some fields of that object. This way projection may occour at levels deeper that the first level. By default the fields 'text', 'favorite_count', 'created_at' are projected. 
    search_params - any other arguments for calling api.search, e.g. lang ("es", "en", ..)

    Returns an iterator of the input list where each dictionary has been extended with a 'tweets' field that contains the result of applying tweet_processor to each tweepy.models.Status returned by the corresponding query to twitter. See https://dev.twitter.com/docs/platform-objects/tweets for the meaning of the fields. 
    '''
    if tweet_processor is None:
        tweet_processor = lambda status: {k : status.__dict__[k] for k in ['text', 'favorite_count', 'created_at']}
    query = (lambda trend : sorted(api.search(q=trend['query'], count=count, result_type = 'popular', **search_params), 
                                   key=lambda r : r.favorite_count, reverse=True)[:count]) if popular\
                else (lambda trend : api.search(q=trend['query'], count=count, **search_params))
    return (dict({"tweets" : [ tweet_processor(status) for status in query(trend) ]}, **trend) 
                 for trend in trends)

def storm_tweet_processor(status):
    shallow_fields = ['text', 'favorite_count', 'retweeted', 'in_reply_to_screen_name',
                      'retweet_count', 'possibly_sensitive', 'lang', 'created_at', 'source']
    ret = {k : status.__dict__.get(k, None) for k in shallow_fields}
    ret['author.screen_name'] = status.author.screen_name
    ret['hashtags.text'] = [hashtag['text'] for hashtag in status.entities['hashtags']]
    ret['place.full_name'] = status.place.full_name if not status.place is None else None
    return ret 

def _test_get_trending_tweets():
    auth = authenticate(rebuild=False)
    api = tweepy.API(auth)
    trends = get_trending_topics_text(api)
    tr = 0
    
    for trend_tweets in get_tweets_for_trends(api, trends, count = 5, popular = True,
                                              tweet_processor = storm_tweet_processor, lang = "es"):
        tr +=1
        print 'tr', tr, '-'*30
        print "trend", trend_tweets["name"]
        for tw, tweet in enumerate(sorted(trend_tweets["tweets"], reverse=True, key=lambda t:t['favorite_count'])):
            print '\t', 'tw', tw+1, tweet

if __name__ == '__main__':
    _test_get_trending_tweets()

