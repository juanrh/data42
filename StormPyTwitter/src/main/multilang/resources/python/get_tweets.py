#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, json, sys
import tweepy

'''
Utils for connecting to Twitter, based on tweepy (https://github.com/tweepy/tweepy)

For python 2.7

Assumming a file twitter_secrets.json with fields "key" and "secret" with a valid tweeter consumer token and secret
'''
_script_dir = os.path.realpath(os.path.dirname(__file__))

# Config
_conf_dir = os.path.join(_script_dir)
_conf = dict()

# Load config file
try: 
    path = os.path.join(_conf_dir, 'conf.json')
    with open(path, 'r') as conf_f:
        _conf = json.load(conf_f)
    path = os.path.join(_conf_dir, 'twitter_secrets.json')
    with open(path, 'r') as conf_f:
        _conf["twitter"].update(json.load(conf_f))
except Exception as e:
    msg = "Error loading configuration from path " + path
    raise RuntimeError(msg, e)

def authenticate(rebuild=False):
    '''
    Return an OAuthHandler after the autentication process.
    If rebuild is true then any access token and key stored in disk will be ignored.

    Following https://pythonhosted.org/tweepy/html/auth_tutorial.html?highlight=oauthhandler

    :param rebuild: If rebuild is True then the autentication process is performed from scratch.
    :type rebuild: bool

    :returns: A tweepy.api.API object ready to use for autentication.

    :raises: RuntimeError        
    '''
    # create OAuthHandler with the consumer token and secret for 
    # the corresponding Twitter app
    auth = tweepy.OAuthHandler(_conf["twitter"]["key"], _conf["twitter"]["secret"])

    # "Twitter currently does not expire the tokens, so the only time it would ever
    # go invalid is if the user revokes our application access." So lets try to 
    # reuse the access token an secret, stored in disk
    credentials_path = os.path.join(_script_dir, _conf["twitter"]["credentials_filename"])
    if (not rebuild) and os.path.exists(credentials_path):
        try: 
            # reuse existing access token and secret
            with open(credentials_path, 'r') as creds_f:
                credentials = json.load(creds_f)
                access_key, access_secret = credentials["access_key"], credentials["access_secret"]
            # rebuild the OAuthHandler with the access and secret key
            auth.set_access_token(access_key, access_secret)
            return auth
        except:
            # try autentication from scratch
            pass
    
    # Otherwise do the OAuth dance: to exchange request token for an access token
    # ask for user autorization using the URL generated by auth from the request 
    # token
        # Ask the use to go to Tweeter to authorize and geting a verifier code
    print "Please go to {url} to authorize the app {app} and input the verifier code here".format(url=auth.get_authorization_url(), app=_conf["twitter"]["appname"])
    verifier_code = raw_input("Verifier code: " )
    try:
        # exchange the request stored in auth token for an access token by providing
        # the verifier code as a proof of user autorization
        auth.get_access_token(verifier_code)
    except tweepy.TweepError as tpe:
        msg = "Error getting access to Twitter app {app}".format(app=_conf["twitter"]["appname"])
        raise RuntimeError(msg, tpe)
    print "Authentication in Twitter for app {app} succeed".format(app=_conf["twitter"]["appname"])
        # Store access token and secret key in disk for future use
    try: 
        with open(credentials_path, 'w') as creds_f:
            json.dump({"access_key" : auth.access_token.key, "access_secret" : auth.access_token.secret}, creds_f)
    except Exception as e:
        msg = "Error saving access token and secret"
        raise RuntimeError(msg, e)
    return auth

def available_places():
    '''
    :returns a dictionary from place names to a dictionary with keys "lat" and "long" for the corresponding longitude and latitute
    '''
    return _conf["places"]

def get_trending_topics_text(api, place=available_places().keys()[0]): #woeid = 23424950):
    '''
    Gets the trending topics closest to the location specified. 

    :param api: API object to use for connecting to Twitter.
    :type api: tweepy.api.API object

    :param place: encodes a location, following the convention in the configuration file FIXME.
    :type place: str

    :returns: A list of dictionaries with keys 'name' and 'query' corresponding to hashtags for the 10 most trending topics for that location, e.g. [{'query': '%22Adolfo+Su%C3%A1rez%22', 'name': u'Adolfo Su\xe1rez'}, ...]
    '''
    response = api.trends_place(api.trends_closest(**_conf["places"][place])[0]["woeid"])
    # Trends have the shape:
    #     {'url': 'http://twitter.com/search?q=%23euroUPyD', 'query': '%23euroUPyD', 'name': '#euroUPyD', 'promoted_content': None, 'events': None}
    return [{k : trend[k] for k in ['name', 'query']} for trend in response[0]['trends'] ]

def get_tweets_for_trends(api, trends, count=15, popular = False, tweet_processor = None, **search_params):
    '''
    Launch a search to Twitter for tweets corresponding to the trend spec in the list trends, that has the format returned by get_trending_topics_text(). 

    :param api: API object to use for connecting to Twitter.
    :type api: tweepy.api.API object

    :param trends: list of dictionaries in the format returned by get_trending_topics_text().

    :param count: number of tweets to retrieve per element in trends.
    :type count: int

    :param popular: whether to search for poular tweets (result_type 'popular' in the queries) or not. This limits the result to 15 tweets maximum ignoring 'count', for what it appears to be a bug https://dev.twitter.com/discussions/19472.
    :type popular: bool

    :param tweet_processor: Function that takes an object of the class tweepy.models.Status and returns a dictionary corresponding to projecting some fields of that object. This way projection may occour at levels deeper that the first level. By default the fields 'text', 'favorite_count', 'created_at' are projected. 
        search_params - any other arguments for calling api.search, e.g. lang ("es", "en", ..)

    :param search_params: Additional keyword arguments to use in the call to api.search for querying Twitter.

    :returns: An iterator of the input list where each dictionary has been extended with a 'tweets' field that contains the result of applying tweet_processor to each tweepy.models.Status returned by the corresponding query to twitter. See https://dev.twitter.com/docs/platform-objects/tweets for the meaning of the fields. 
    '''
    if tweet_processor is None:
        tweet_processor = lambda status: {k : status.__dict__[k] for k in ['text', 'favorite_count', 'created_at']}
    query = (lambda trend : sorted(api.search(q=trend['query'], count=count, result_type = 'popular', **search_params), 
                                   key=lambda r : r.favorite_count, reverse=True)[:count]) if popular\
                else (lambda trend : api.search(q=trend['query'], count=count, **search_params))
    return (dict({"tweets" : [ tweet_processor(status) for status in query(trend) ]}, **trend) 
                 for trend in trends)

def example_tweet_processor(status):
        shallow_fields = ['text', 'favorite_count', 'retweeted', 'in_reply_to_screen_name',
                          'retweet_count', 'possibly_sensitive', 'lang', 'created_at', 'source']
        ret = {k : status.__dict__.get(k, None) for k in shallow_fields}
        ret['author.screen_name'] = status.author.screen_name
        ret['hashtags.text'] = [hashtag['text'] for hashtag in status.entities['hashtags']]
        ret['place.full_name'] = status.place.full_name if not status.place is None else None
        return ret

if __name__ == '__main__':
    print "Starting authentication setup"
    auth = authenticate(rebuild=False)
    print "Testing authentication"
    api = tweepy.API(auth)
    trends = get_trending_topics_text(api)
    print "Trending topics for {place}:".format(place=available_places().keys()[0])
    print "\t", trends
    print 
    print "Finished authentication setup"

